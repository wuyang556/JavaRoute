### Java 基础

#### 修饰符

##### 访问修饰符

Java的访问修饰符有以下几种 public，protected，default 和 private。

对于外部类只能被两种访问修饰符所修饰：public 和 default，因为外部类有两个作用域：同包和任何位置，对应着两种控制权限：包控制权限和访问控制权限。

![](https://s1.ax1x.com/2020/09/05/wEmwfU.png)

1. public
   - 修饰类：在所有范围里都可见
   - 修饰变量：
     - 静态变量：在所有范围类可见
     - 实例变量：在所有范围类可见
   - 修饰方法：
     - 静态方法：在所有范围类可见
     - 实例方法：在所有范围类可见
2. protected
   - 不能修饰外部类，只能用来修饰内部类
   - 修饰变量：
     - 静态变量：对于同一包下的子类和非子类可见，对于非同一包下的子类可见，非子类不可见
     - 实例变量：对于同一包下的子类和非子类可见，对于非同一包下的子类和非子类不可见
   - 修饰方法：同上
3. default
   - 修饰类：只对同一包下的类（子类和非子类）可见
   - 修饰变量：同上
   - 修饰方法：同上
4. private
   - 不能修饰外部类，只能用来修饰内部类：表明该类不能被继承
   - 修饰变量：
     - 静态变量：仅对本类可见
     - 实例变量：同上
   - 修饰方法：同上

##### 非访问修饰符

1. static 修饰符

   用来修饰类方法和类变量

2. final 修饰符

   可用来修饰类，变量，方法

   final，finally 和 finalize 的区别

3. abstract 修饰符

   用来创建抽象类和抽象方法

   - 一个类不能同事被 abstract 和 final 修饰
   - 如果一个类包含抽象方法，那么必须被声明为抽象类

4. synchronized 和 volatile 修饰符

   用于线程

5. transient 修饰符

   修饰变量，不会被序列化

   - 被 static 或 transient 修饰的类变量或实例变量不会被序列化

参考：

1. [Java 的外部类为什么不能使用 private，protecetd 进行修饰](https://blog.csdn.net/yangyong0717/article/details/78379760/)
2. [Java 修饰符](https://www.runoob.com/java/java-modifier-types.html#protected-desc)

#### 堆和栈的区别

1. 堆

   new的新对象都是存储在堆中，垃圾回收器回收的主要对象，相较于栈，堆中的对象实体占用内存的释放依赖于垃圾回收器

2. 栈

   栈中存储的是局部变量，变量的生命周期一旦结束就会占用的内存就会被释放，栈中存储的局部变量占用内存的释放依赖于其生命周期

参考：

1. [Java 中堆和栈的区别](https://www.php.cn/java/guide/434957.html)

#### volatile 的作用和实现原理

1. 作用：
   - 禁止指令重排
   - 可以保证变量的可见性
   - 不能保证操作的原子性
2. 实现 volatile 的原理
   - 内存屏障

参考：

1. [深入理解 volatile 关键字及其实现原理](https://blog.csdn.net/zezezuiaiya/article/details/81456060)

#### 线程同步的三大特性

1. 原子性
2. 有序性
3. 可见性

#### + 的特殊使用

先看下边的例子：

~~~Java
int a = 1;
int b = 2;
System.out.println(""+a+b);  // 12
System.out.println(a+b+"");  // 3
~~~

如上，+ 是一种二元运算符，它的运算方向是从左到右，会根据+两边操作数的类型自动做出改变，选择自身是普通的加号运算符还是字符串连接。

#### 引用传递和值传递

Java 中只存在值传递，对于基本类型变量，传递到方法中的实参，是原有数据的一份拷贝，无论在方法体中这份拷贝数据如何修改，都不会影响到原始数据。而对于引用类型变量，传递到方法中的实参是一份引用的拷贝，同样在方法体内部对拷贝到的引用（这是一种浅拷贝）如何变动，都不会影响到原始变量的引用对象是否会发生变化，但是在方法体中对引用实例的修改操作会直接有效反应出来。所以 Java 中只存在值传递的含义就是传递的参数是不会影响到原始数据。

#### 深拷贝和浅拷贝

对于基本类型，深浅拷贝都是值传递。

对于引用类型：

- 浅拷贝：引用传递，对于引用变量之间的赋值，就是浅拷贝。
- 深拷贝：完全复制，创建出一个新对象。

#### 成员变量和局部变量

区别：

1. 语法：成员变量可以被访问修饰符和Static修饰，而局部变量却不行
2. 在内存中的存储方式：如果成员变量被static修饰，那么它是静态变量，属于类，它会被存储在方法区中。如果没有被static修饰，那么它是实例变量，属于类的实例化对象，而对象实体会被存储在堆中。对于局部变量，它的产生伴随着方法的调用执行，方法使用的内存空间是虚拟机栈，每个线程私有一个栈，而方法对应着栈帧，栈帧中有局部变量表，操作数栈，方法出口，动态链接等。
3. 生命周期：实例变量是对象的一部分，它伴随着对象。局部变量是随着方法的调用而自动消失。
4. 成员变量可以不被自动赋初值（被final修饰的成员变量必须被显示赋初值），而局部变量不会被自动赋值。

#### 如何创建一个对象？对象实体和对象引用有什么不同？

通过 new 关键字可以创建一个对象实体，对象实例存储在堆内存上。

对象引用指向对象实体，一个对象引用可以有0或1个对象。对象引用存储在占内存中。

一个对象实体可以被 n 个对象引用指向。

#### 构造方法的作用和特点分别是什么？

作用：初始化对象，完成对象实体的初始化操作

特点：

1. 一个类中如果没有构造方法，会默认存在一个不带参数的构造方法。但是如果添加了带参数的构造方法，那么 Java 就不会添加一个默认的无参构造方法。所以如果重载了一个有参构造方法，最好要把无参构造方法也写出来。
2. 名字和类相同
3. 没有返回值，不需要使用返回值类型。
4. 只能被重载，不能被重写。
5. 在创建类的实例化对象时，自动被调用。在调用子类的构造方法之前会先调用父类的构造方法。

#### 面向对象的三大特性，它们的特点分别是什么？

继承

一个类只可以继承一个父类，但可以实现多个接口。

特点：

1. 子类可以拥有父类的所有属性和方法，但是父类中的私有方法和私有属性子类无法访问。
2. 子类可以对父类进行扩展。
3. 子类可以重载父类方法。

封装

类将属性隐藏在内部，不允许外部直接访问内部信息。但是可以提供一些可以供外界访问的方法。

多态：

多态是指一个对象会有多种状态，具体表现就是父类的引用指向子类的实例。

特点：

1. 方法可以具备多态性，属性无法具备多态性。
2. 对象类型不可变，引用类型可变。
3. 对象类型和引用类型之间具有继承/实现的关系。
4. 多态不能用于 “只在子类中存在但在父类中不存在”的方法。
5. 引用类型变量发出的方法调用到底是哪个类的方法，只能在程序运行期才能确定。
6. 如果子类重写了父类方法，真正执行的是子类覆盖的方法，如果没有覆盖，那么执行的是父类方法。

---

#### 抽象类和接口的异同

抽象类：

1. 抽象类不能被实例化，但是可以被声明。使用abstract声明

2. 抽象类中必须有一个抽象方法，且abstract关键字不可省略。

3. 抽象类中可以有其他成员方法。

接口：

1. 接口不能被实例化，但是可以被声明。

2. 接口使用interface关键字声明。

3. 接口中的方法，默认使用public abstact修饰，可省略。

4. 接口中属性默认使用final修饰，可省略。

```Java
abstract class test{
    abstract void print();
}

interface test2{
    void print();
}
```

一个类可以实现多个接口，但一个类只能继承一个类。抽象类是对类的抽象，倾向于是一种模板，而接口是对行为的抽象，是一种行为的规范。

---

#### 线程的生命状态

![](https://s1.ax1x.com/2020/08/12/avUogU.png)

---

#### final，static，this，super 关键字

final

特点：

1. 修饰类，则该类不能被继承，且该类的所有成员方法都会被隐式指定为final方法
2. 修饰方法，则该方法不能被重写
3. 修饰变量，若是基本类型变量，则数值在初始化后就不能被修改。若是引用类型变量，则在初始化后不能指向其他对象。类中所有的private方法都被隐式指定为final方法。

static

特点：

1. 修饰变量和方法：被static修饰的成员属于类，为类的所有实例共享。
2. 静态代码块：类不管会创建多少新对象，但是静态代码块只会执行一次。静态代码块 -> 非静态代码块 -> 构造方法
   - 非静态代码块和构造方法的区别：非静态代码块是给所有对象进行统一初始化，构造方法是给对应的对象做初始化。非静态代码块在每次new新对象都会执行一次，而静态代码块只在第一次new新对象或创建Class对象才会执行一次，且之后不会再执行。
3. 静态内部类：
   - 静态内部类的创建不依赖外部类的创建。
   - 不能使用外部类的非 static 成员变量和方法。

this

用于引用类的当前实例。

super

用于从子类中调用父类方法。

注意：this和super是属于对象范畴的，而static是属于类范畴的，所以this和super不能在静态方法和静态代码块中使用。

---

#### 浮点数比较

先看下边的例子：

```java
System.out.println(0.3*2 == 0.6)  // true
System.out.println(3*0.2 == 0.6)  // false
System.out.prinln(0.3*0.2 == 0.06)  // true
System.out.println(.3*.2==.6*.1);  // true
System.out.println(3*.02==.06);  // true
```

上述情况的出现，是因为浮点数精度损失。

原则上：

- 对于浮点数之间的等值判断，基本类型不能简单地使用 == 来比较，包装数据类型不能使用 equals 来判断。

- 可以使用BigDecimal来定义浮点数的值，再进行浮点数的运算操作和比较。

参考：

1. [Java 中 3\*0.1 == 0.3 返回 false，1\*0.3 == 0.3 返回 true](https://blog.csdn.net/icecoola_/article/details/78163640)
2. [为什么0.1+0.2=0.30000000000000004而1.1+2.2=3.3000000000000003？](https://blog.csdn.net/ialexanderi/article/details/78936466)

---

#### Iterator 和 Iterable 的区别

---

#### Comparable 和 Compator 的区别

---

#### 枚举

参考：

1. - [ ] :badminton:[用好Java中的枚举真的没有那么简单]([https://snailclimb.gitee.io/javaguide/#/docs/java/basic/%E7%94%A8%E5%A5%BDJava%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%9C%9F%E7%9A%84%E6%B2%A1%E6%9C%89%E9%82%A3%E4%B9%88%E7%AE%80%E5%8D%95](https://snailclimb.gitee.io/javaguide/#/docs/java/basic/用好Java中的枚举真的没有那么简单))

---

#### 反射

Java的反射是指在程序运行状态中，对于任意一个类，可以获得类的所有属性和方法，对于任意一个对象。可以调用其任意的方法和属性。

反射就是将类中的各个成分映射为Java中的对象。

获取Class对象的几种方式：

1. Class.forName()
2. 类名.class
3. 对象.getClass()

优缺点：



参考：

1. - [ ] :baby_chick:[反射机制介绍](https://snailclimb.gitee.io/javaguide/#/docs/java/basic/reflection)
2. - [ ] :baby_chick:[Java 反射使用总结](https://zhuanlan.zhihu.com/p/80519709)
3. - [ ] :baby_chick:[反射的应用场景](https://segmentfault.com/a/1190000010162647?utm_source=tuicool&utm_medium=referral)
4. - [ ] :baby_chick:[Java 基础之反射](https://blog.csdn.net/sinat_38259539/article/details/71799078)

---

#### 动态编译和静态编译

---

#### 代理模式

静态代理

动态代理

1. JDK 动态代理
2. CGLIB 动态代理

参考：

1. - [ ] :baby_bottle:[代理模式](https://snailclimb.gitee.io/javaguide/#/docs/java/basic/java-proxy)

---

#### 定位常见Java性能问题

参考：

1. - [ ] :baby:[手把手教你定位常见Java性能问题]([https://snailclimb.gitee.io/javaguide/#/./docs/java/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%9A%E4%BD%8D%E5%B8%B8%E8%A7%81Java%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98](https://snailclimb.gitee.io/javaguide/#/./docs/java/手把手教你定位常见Java性能问题))

---

#### 集合框架

##### 迭代器 Iterator



##### ArrayList 源码解析

##### LinkedList 源码解析

##### HashMap 源码解析

##### ConcurrentHashMap 源码解析

参考：

1. - [ ] :hatching_chick:[ArrayList 源码](https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList) 
2. - [ ] :hatching_chick:[LinkedList 源码](https://snailclimb.gitee.io/javaguide/#/docs/java/collection/LinkedList)
3. - [ ] :hatching_chick:[HashMap(JDK1.8)源码](https://snailclimb.gitee.io/javaguide/#/docs/java/collection/HashMap)
4. - [ ] :hatching_chick:[ConcurrentHashMap源码](https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ConcurrentHashMap)

----

#### 并发编程

参考：

1. 

### 数据库

#### MySQL

##### 如何实现分页操作

1. 使用 limit

---

##### 慢查询优化方法

---

### 计算机网络

#### 状态码

---

#### Cookie 和 Session 的区别

---



