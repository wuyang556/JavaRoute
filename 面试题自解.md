### Java 基础

#### 修饰符

##### 访问修饰符

Java的访问修饰符有以下几种 public，protected，default 和 private。

对于外部类只能被两种访问修饰符所修饰：public 和 default，因为外部类有两个作用域：同包和任何位置，对应着两种控制权限：包控制权限和访问控制权限。

![](https://s1.ax1x.com/2020/09/05/wEmwfU.png)

1. public
   - 修饰类：在所有范围里都可见
   - 修饰变量：
     - 静态变量：在所有范围类可见
     - 实例变量：在所有范围类可见
   - 修饰方法：
     - 静态方法：在所有范围类可见
     - 实例方法：在所有范围类可见
2. protected
   - 不能修饰外部类，只能用来修饰内部类
   - 修饰变量：
     - 静态变量：对于同一包下的子类和非子类可见，对于非同一包下的子类可见，非子类不可见
     - 实例变量：对于同一包下的子类和非子类可见，对于非同一包下的子类和非子类不可见
   - 修饰方法：同上
3. default
   - 修饰类：只对同一包下的类（子类和非子类）可见
   - 修饰变量：同上
   - 修饰方法：同上
4. private
   - 不能修饰外部类，只能用来修饰内部类：表明该类不能被继承
   - 修饰变量：
     - 静态变量：仅对本类可见
     - 实例变量：同上
   - 修饰方法：同上

##### 非访问修饰符

1. static 修饰符

   用来修饰类方法和类变量

2. final 修饰符

   可用来修饰类，变量，方法

   final，finally 和 finalize 的区别

3. abstract 修饰符

   用来创建抽象类和抽象方法

   - 一个类不能同事被 abstract 和 final 修饰
   - 如果一个类包含抽象方法，那么必须被声明为抽象类

4. synchronized 和 volatile 修饰符

   用于线程

5. transient 修饰符

   修饰变量，不会被序列化

   - 被 static 或 transient 修饰的类变量或实例变量不会被序列化

参考：

1. [Java 的外部类为什么不能使用 private，protecetd 进行修饰](https://blog.csdn.net/yangyong0717/article/details/78379760/)
2. [Java 修饰符](https://www.runoob.com/java/java-modifier-types.html#protected-desc)

#### 堆和栈的区别

1. 堆

   new的新对象都是存储在堆中，垃圾回收器回收的主要对象，相较于栈，堆中的对象实体占用内存的释放依赖于垃圾回收器

2. 栈

   栈中存储的是局部变量，变量的生命周期一旦结束就会占用的内存就会被释放，栈中存储的局部变量占用内存的释放依赖于其生命周期

参考：

1. [Java 中堆和栈的区别](https://www.php.cn/java/guide/434957.html)

#### volatile 的作用和实现原理

1. 作用：
   - 禁止指令重排
   - 可以保证变量的可见性
   - 不能保证操作的原子性
2. 实现 volatile 的原理
   - 内存屏障

参考：

1. [深入理解 volatile 关键字及其实现原理](https://blog.csdn.net/zezezuiaiya/article/details/81456060)

#### 线程同步的三大特性

1. 原子性
2. 有序性
3. 可见性

#### + 的特殊使用

先看下边的例子：

~~~Java
int a = 1;
int b = 2;
System.out.println(""+a+b);  // 12
System.out.println(a+b+"");  // 3
~~~

如上，+ 是一种二元运算符，它的运算方向是从左到右，会根据+两边操作数的类型自动做出改变，选择自身是普通的加号运算符还是字符串连接。

#### 引用传递和值传递

Java 中只存在值传递，对于基本类型变量，传递到方法中的实参，是原有数据的一份拷贝，无论在方法体中这份拷贝数据如何修改，都不会影响到原始数据。而对于引用类型变量，传递到方法中的实参是一份引用的拷贝，同样在方法体内部对拷贝到的引用（这是一种浅拷贝）如何变动，都不会影响到原始变量的引用对象是否会发生变化，但是在方法体中对引用实例的修改操作会直接有效反应出来。所以 Java 中只存在值传递的含义就是传递的参数是不会影响到原始数据。

#### 深拷贝和浅拷贝

对于基本类型，深浅拷贝都是值传递。

对于引用类型：

- 浅拷贝：引用传递，对于引用变量之间的赋值，就是浅拷贝。
- 深拷贝：完全复制，创建出一个新对象。

#### 成员变量和局部变量

区别：

1. 语法：成员变量可以被访问修饰符和Static修饰，而局部变量却不行
2. 在内存中的存储方式：如果成员变量被static修饰，那么它是静态变量，属于类，它会被存储在方法区中。如果没有被static修饰，那么它是实例变量，属于类的实例化对象，而对象实体会被存储在堆中。对于局部变量，它的产生伴随着方法的调用执行，方法使用的内存空间是虚拟机栈，每个线程私有一个栈，而方法对应着栈帧，栈帧中有局部变量表，操作数栈，方法出口，动态链接等。
3. 生命周期：实例变量是对象的一部分，它伴随着对象。局部变量是随着方法的调用而自动消失。
4. 成员变量可以不被自动赋初值（被final修饰的成员变量必须被显示赋初值），而局部变量不会被自动赋值。

#### 如何创建一个对象？对象实体和对象引用有什么不同？

通过 new 关键字可以创建一个对象实体，对象实例存储在堆内存上。

对象引用指向对象实体，一个对象引用可以有0或1个对象。对象引用存储在占内存中。

一个对象实体可以被 n 个对象引用指向。

#### 构造方法的作用和特点分别是什么？

作用：初始化对象，完成对象实体的初始化操作

特点：

1. 一个类中如果没有构造方法，会默认存在一个不带参数的构造方法。但是如果添加了带参数的构造方法，那么 Java 就不会添加一个默认的无参构造方法。所以如果重载了一个有参构造方法，最好要把无参构造方法也写出来。
2. 名字和类相同
3. 没有返回值，不需要使用返回值类型。
4. 只能被重载，不能被重写。
5. 在创建类的实例化对象时，自动被调用。在调用子类的构造方法之前会先调用父类的构造方法。

#### 面向对象的三大特性，它们的特点分别是什么？

继承

一个类只可以继承一个父类，但可以实现多个接口。

特点：

1. 子类可以拥有父类的所有属性和方法，但是父类中的私有方法和私有属性子类无法访问。
2. 子类可以对父类进行扩展。
3. 子类可以重载父类方法。

封装

类将属性隐藏在内部，不允许外部直接访问内部信息。但是可以提供一些可以供外界访问的方法。

多态：

多态是指一个对象会有多种状态，具体表现就是父类的引用指向子类的实例。

特点：

1. 方法可以具备多态性，属性无法具备多态性。
2. 对象类型不可变，引用类型可变。
3. 对象类型和引用类型之间具有继承/实现的关系。
4. 多态不能用于 “只在子类中存在但在父类中不存在”的方法。
5. 引用类型变量发出的方法调用到底是哪个类的方法，只能在程序运行期才能确定。
6. 如果子类重写了父类方法，真正执行的是子类覆盖的方法，如果没有覆盖，那么执行的是父类方法。

---

#### 抽象类和接口的异同

抽象类：

1. 抽象类不能被实例化，但是可以被声明。使用abstract声明

2. 抽象类中必须有一个抽象方法，且abstract关键字不可省略。

3. 抽象类中可以有其他成员方法。

接口：

1. 接口不能被实例化，但是可以被声明。

2. 接口使用interface关键字声明。

3. 接口中的方法，默认使用public abstact修饰，可省略。

4. 接口中属性默认使用final修饰，可省略。

```Java
abstract class test{
    abstract void print();
}

interface test2{
    void print();
}
```

一个类可以实现多个接口，但一个类只能继承一个类。抽象类是对类的抽象，倾向于是一种模板，而接口是对行为的抽象，是一种行为的规范。

---

#### 线程的生命状态

![](https://s1.ax1x.com/2020/08/12/avUogU.png)

---

#### final，static，this，super 关键字

final

特点：

1. 修饰类，则该类不能被继承，且该类的所有成员方法都会被隐式指定为final方法
2. 修饰方法，则该方法不能被重写
3. 修饰变量，若是基本类型变量，则数值在初始化后就不能被修改。若是引用类型变量，则在初始化后不能指向其他对象。类中所有的private方法都被隐式指定为final方法。

static

特点：

1. 修饰变量和方法：被static修饰的成员属于类，为类的所有实例共享。
2. 静态代码块：类不管会创建多少新对象，但是静态代码块只会执行一次。静态代码块 -> 非静态代码块 -> 构造方法
   - 非静态代码块和构造方法的区别：非静态代码块是给所有对象进行统一初始化，构造方法是给对应的对象做初始化。非静态代码块在每次new新对象都会执行一次，而静态代码块只在第一次new新对象或创建Class对象才会执行一次，且之后不会再执行。
3. 静态内部类：
   - 静态内部类的创建不依赖外部类的创建。
   - 不能使用外部类的非 static 成员变量和方法。

this

用于引用类的当前实例。

super

用于从子类中调用父类方法。

注意：this和super是属于对象范畴的，而static是属于类范畴的，所以this和super不能在静态方法和静态代码块中使用。

---

#### 浮点数比较

先看下边的例子：

```java
System.out.println(0.3*2 == 0.6)  // true
System.out.println(3*0.2 == 0.6)  // false
System.out.prinln(0.3*0.2 == 0.06)  // true
System.out.println(.3*.2==.6*.1);  // true
System.out.println(3*.02==.06);  // true
```

上述情况的出现，是因为浮点数精度损失。

原则上：

- 对于浮点数之间的等值判断，基本类型不能简单地使用 == 来比较，包装数据类型不能使用 equals 来判断。

- 可以使用BigDecimal来定义浮点数的值，再进行浮点数的运算操作和比较。

参考：

1. [Java 中 3\*0.1 == 0.3 返回 false，1\*0.3 == 0.3 返回 true](https://blog.csdn.net/icecoola_/article/details/78163640)
2. [为什么0.1+0.2=0.30000000000000004而1.1+2.2=3.3000000000000003？](https://blog.csdn.net/ialexanderi/article/details/78936466)

---

#### Iterator 和 Iterable 的区别

##### Iterator 和 Enummeration 的区别

---

#### Comparable 和 Compator 的区别

---

#### 手写线程安全的单例模式

1. 使用静态内部类

~~~java
public class SingleTon{
  private SingleTon(){}
 
  private static class SingleTonHoler{
     private static SingleTon INSTANCE = new SingleTon();
 }
 
  public static SingleTon getInstance(){
    return SingleTonHoler.INSTANCE;
  }
}
~~~

2. 使用双重校验锁

~~~java

~~~

3. 使用枚举

~~~java

~~~

单例模式实现的原则：

1. 构造器私有化
2. 以静态方法或枚举返回实例
3. 确保实例只有一个，尤其是在多线程环境下
4. 确保反序列化不会重新构建对象

参考：

1. - [ ] 

---

#### 枚举

参考：

1. - [ ] :badminton:[用好Java中的枚举真的没有那么简单]([https://snailclimb.gitee.io/javaguide/#/docs/java/basic/%E7%94%A8%E5%A5%BDJava%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%9C%9F%E7%9A%84%E6%B2%A1%E6%9C%89%E9%82%A3%E4%B9%88%E7%AE%80%E5%8D%95](https://snailclimb.gitee.io/javaguide/#/docs/java/basic/用好Java中的枚举真的没有那么简单))

---

#### 反射

Java的反射是指在程序运行状态中，对于任意一个类，可以获得类的所有属性和方法，对于任意一个对象。可以调用其任意的方法和属性。

反射就是将类中的各个成分映射为Java中的对象。

获取Class对象的几种方式：

1. Class.forName()
2. 类名.class
3. 对象.getClass()

优缺点：

1. 优点：
   - 增加程序的灵活性

2. 缺点：
   - 破环类的封装性，降低安全性能，
   - 消耗性能

应用场景：

1. 框架
2. JDBC加载驱动器
3. 抽象工厂模式

##### Java 中 Class 对象详解

在Java中，一切皆是对象，从某种意义上，Java中有两种对象，实例对象和Class对象，每个类的运行时类型信息就是使用Class对象表示的，Class对象包含了类的有关信息，实例对象也是通过Class对象来创建的，Java 中使用Class对象执行运行时类型识别（RTTI），多态就是基于RTTI实现的。

每个类都有一个Class对象，每当编译一个新类就会产生一个Class对象，基本类型有Class对象，数组有Class对象，关键字void也有Class对象。Class对象对应着java.lang.Class类，类是对象的抽象和集合，Class类是对类的抽象和集合。

Class类没有公共构造方法，Class对象是在类加载时，jvm通过调用类加载器的defineClass方法自动构造的，无法显式声明一个Class对象

参考：

1. - [ ] :baby_chick:[反射机制介绍](https://snailclimb.gitee.io/javaguide/#/docs/java/basic/reflection)
2. - [ ] :baby_chick:[Java 反射使用总结](https://zhuanlan.zhihu.com/p/80519709)
3. - [ ] :baby_chick:[反射的应用场景](https://segmentfault.com/a/1190000010162647?utm_source=tuicool&utm_medium=referral)
4. - [ ] :baby_chick:[Java 基础之反射](https://blog.csdn.net/sinat_38259539/article/details/71799078)
5. - [ ] :baby_chick:[Java 中 Class 对象的详解](https://blog.csdn.net/dufufd/article/details/80537638)

---

#### JVM

##### 类文件结构

1. 魔数

   class文件的头四个字节，确定文件是否能被JVM接受

2. 文件版本：存储class文件的版本号，第五和第六是次版本号，第七和第八是主版本号。

   高版本的JVM可以执行低版本编译器生成的class文件，反之不可。

3. 常量池

   - 符号引用
     - 类和接口的全限定名
     - 字段的名称和描述
     - 方法的名称和描述

4. 访问标志

   占两个字节，用于识别类或接口层次的访问信息。

5. 当前类索引，父类索引与接口索引集合

   索引即是用于确定全限定名。

6. 字段表集合

   字段包括类变量和实例变量，但不包括在方法内部声明的局部变量。

7. 方法表集合

   结构：

   - 访问标志
   - 名称索引
   - 描述符索引
   - 属性表集合

8. 属性表集合

##### JVM 配置常用参数

概览：

![](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0.png)

##### 堆参数

![](https://snailclimb.gitee.io/javaguide/media/pictures/jvm/java_jvm_heap_parameters.png)

##### 回收器参数

![](https://snailclimb.gitee.io/javaguide/media/pictures/jvm/java_jvm_garbage_collector_parameters.png)



##### 垃圾收集器

###### STW

stop the world 即在执行GC时，Java 应用程序的其他所有除了垃圾收集器线程之外的线程都被挂起

#### GC 调优

多数的 Java 应用不需要在服务器上进行 GC 优化，多数导致 GC 问题的 Java 应用，不是因为参数设置错误而是因为代码的问题。GC 优化是到最后不得已才使用的手段。

原则：

1. 应用上线前，先考虑将JVM的参数设置为最优
2. 减少创建对象的数量
3. 减少使用全局变量和大对象。

目的：

1. 将转移到老年代的对象数量降低到最小
2. 减少GC的执行时间

策略：

1. 将新对象预留在新生代

   因为 Full GC的成本远高于Minor GC，根据GC日志分析新生代空间大小分配是否合理，-Xmn

2. 大对象直接进入老年代。

3. 合理设置进入老年代对象的年龄。

4. 设置稳定的堆大小

   两个参数：

   - 初始化堆大小 -Xms
   - 最大堆大小 -Xmx

5. 满足以下条件，则不需要调优：

   - Minor GC 执行时间不到50ms
   - Minor GC 执行不频繁，约10s一次

   - Full GC执行时间不到1s
   - Full GC执行不频繁，约10min一次

   #### 动态编译和静态编译

---

#### 代理模式

静态代理

动态代理

1. JDK 动态代理
2. CGLIB 动态代理

参考：

1. - [ ] :baby_bottle:[代理模式](https://snailclimb.gitee.io/javaguide/#/docs/java/basic/java-proxy)

---

#### 定位常见Java性能问题

参考：

1. - [ ] :baby:[手把手教你定位常见Java性能问题]([https://snailclimb.gitee.io/javaguide/#/./docs/java/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%9A%E4%BD%8D%E5%B8%B8%E8%A7%81Java%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98](https://snailclimb.gitee.io/javaguide/#/./docs/java/手把手教你定位常见Java性能问题))

---

#### 集合框架

##### 迭代器 Iterator

#### 快速失败（fail-fast）和安全失败（fail-safe）的区别

##### ArrayList 源码解析

ArrayList 和 Vector 的区别

1. 线程安全上：
2. 底层数据结构上：
3. 

##### LinkedList 源码解析

##### HashMap 源码解析

##### ConcurrentHashMap 源码解析

##### HashMap 的遍历方式

参考：

1. - [ ] :hatching_chick:[ArrayList 源码](https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList) 
2. - [ ] :hatching_chick:[LinkedList 源码](https://snailclimb.gitee.io/javaguide/#/docs/java/collection/LinkedList)
3. - [ ] :hatching_chick:[HashMap(JDK1.8)源码](https://snailclimb.gitee.io/javaguide/#/docs/java/collection/HashMap)
4. - [ ] :hatching_chick:[ConcurrentHashMap源码](https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ConcurrentHashMap)
5. - [ ] :hatching_chick:[HashMap 的 7 种遍历方式与性能分析！](https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow)

----

#### 一个对象的创建销毁过程



---

#### 常用的JVM参数

---

#### 并发编程

#### ConcurrentHashMap 和 Hashtable 的区别？

#### HashMap 在多线程下的死循环问题

#### Synvhromized 和 volatile 关键字的区别

两者是互补的存在，而非对立的存在。

1. volatile是线程同步的轻量级实现，性能要比synchronized要好
2. 多线程访问volatile关键字不会发生阻塞，而synchronized关键字会发生阻塞。
3. volatile主要是用来解决变量在多个线程之间的可见性，synchronized则是解决多个线程之间访问资源的同步性。

#### 线程池

池化技术的思想主要是减少每次获取资源的消耗，提高对资源的利用率，有线程池，数据库连接池，HTTP连接池。

线程池的好处：

1. 降低资源的消耗
2. 提高响应速度
3. 提高线程的可管理性

this逃逸问题：在构造器返回之前其他线程就持有该对象的引用，即被调用了尚未被构造完成的对象，会产生令人困惑的错误。

##### Executor 框架

Executor 来启动线程可以避免this逃逸问题

ThreadPoolExecutor的3个重要参数：

1. corePoolSize：核心线程数定义了最小可以同时运行的线程数量
2. maximumPoolSize：当队列存放任务达到队列容量时，当前可以同时运行的线程数量转变为最大线程数。
3. workQueue：当新任务来临时会先判断当前运行的线程数是否达到核心线程数，如果达到的话，新任务会被放到队列中。

其他常见参数：

1. keepAliveTime：
2. unit：
3. threadFactory：Executor 创建新线程使用
4. handler：饱和策略

参考：

1. 

---

#### 乐观锁与悲观锁

##### 乐观锁

##### 悲观锁

##### CAS 与 Synchronized 的使用场景

参考：

1. [悲观锁与乐观锁]([https://snailclimb.gitee.io/javaguide/#/docs/essential-content-for-interview/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E4%B9%8B%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81](https://snailclimb.gitee.io/javaguide/#/docs/essential-content-for-interview/面试必备之乐观锁与悲观锁))
2. [《 面试必备之深入理解自旋锁》](https://blog.csdn.net/qq_34337272/article/details/81252853)

### 数据库

#### MySQL

##### 如何实现分页操作

1. 使用 limit

---

##### 慢查询优化方法（大表优化）

1. 限定数据范围
2. 读/写分离
3. 垂直分区
4. 水平分区

参考：

- [SQL 查询速度慢原因及优化方法](https://blog.csdn.net/GX_1_11_real/article/details/88699445)
- [腾讯面试：一条SQL语句执行得很慢的原因有哪些？---不看后悔系列](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485185&idx=1&sn=66ef08b4ab6af5757792223a83fc0d45&chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&token=79317275&lang=zh_CN#rd)

---

##### MySQL 如何为表字段添加索引？有几种方式？

1. 添加主键索引（PRIMARY KEY）

~~~mysql
ALTER TABLE table_name ADD PRIMARY KEY (`column`);
~~~

2. 添加唯一索引（UNIQUE）

~~~;mysql
ALTER TABLE table_name ADD UNIQUE (`column`);
~~~

3. 添加普通索引（INDEX）

```mysql
ALTER TABLE table_name ADD INDEX index_name (`column`);
```

4. 添加全文索引（FULLTEXT）

```mysql
ALTER TABLE table_name ADD FULLTEXT (`column`);
```

5. 添加多列索引

```mysql
ALTER TABLE table_name ADD INDEX index_name (`column1`, `column2`, `column3`);
```

----

##### MySQL 的索引

1. 哈希索引
2. B+Tree索引
3. 全文索引

```mysql
# 查看表中的索引
show index from table_name
```

---

##### 存储引擎 MyISAM 和 InnoDB 的区别？

1. MyISAM

   MyISAM是5.7之前MySQL的默认存储引擎，支持表级锁，使用的索引是B+树，但是叶子节点上存储的是指向数据的指针，且不支持事务操作。使用MyISAM数据和索引分离，

2. InnoDB

   InnoDB是5.7之后的默认存储引擎，支持表级锁和行级锁，可以支持事务，索引使用的数据结构是B+树，叶子节点上存储的是数据。使用InnoDB数据和索引不分离，保存在同一个文件中。

区别:

1. 是否支持行级锁：MyISAM只支持表级锁，而InnoDB支持行级锁和表级锁，默认支持行级锁
2. 是否支持事务和崩溃后的安全恢复：MyISAM 强调的是性能，每次查询具有原子性，其执行速度比 InnoDB 快，但不支持事务，InnoDB提供事务支持和外部键等高级数据库功能。
3. 是否支持外键：MyISAM不支持，InnoDB支持。
4. 是否支持MVCC：仅InnoDB支持。应对高并发事务，MVCC比单纯的加锁更高效，使用乐观锁和悲观锁实现，仅在读取已提交和可重复读两个事务隔离级别下工作

````mysql
# 查看当前默认存储引擎
show variables like `%storage_engine%`

# 查看表的存储引擎
show table status like `table_name`
````

----

##### 使用索引的一些原则，注意事项

1. 最左前缀原则
2. 注意避免冗余索引
3. 选择合适的字段

---

##### 什么是联合索引，覆盖索引，聚簇索引，非聚簇索引，MySQL索引使用的两种数据结构是什么？

1. 联合索引
2. 覆盖索引
3. 聚簇索引
4. 非聚簇索引
5. 索引使用的两种数据结构：
   - 哈希
   - B+树

---

##### 什么是索引，索引有什么优势和缺点，为什么要使用索引，怎么高效使用索引？

索引是一种可以加快数据库检索速度的数据结构，常见的索引有：B+树索引，哈希索引和全文索引，索引使用的数据结构主要有B+树，B树和哈希。其作用和书籍的目录类似，可以快速定位数据。

索引的最大优势就是可以加快数据检索的速度，这也是创建和使用索引的主要原因，因为大部分系统的服务都是读请求大于写请求的。创建唯一索引，可以保证表中每一行数据的唯一性。

索引的缺点：

1. 创建索引和维护索引需要消耗很多时间，并且对表中的数据进行增删时，当数据有索引，还需要对索引动态修改，会降低SQL语句的效率。
2. 占用物理存储空间，因为索引需要使用物理文件存储。

---

##### 使用索引就一定可以提高查询性能吗？

主要看数据库的数据量，量大就快，量小不一定会在速度上带来提升，在绝大多数情况下，索引查询是要比全表扫描要

---

##### 哈希索引和B+树索引两者的优劣势是什么？

哈希索引的最大优势是定位快，但是哈希索引不支持顺序和范围索引。

B+树

---

##### 列举出索引的类型

分类1：

1. 主键索引

   主键列使用的就是主键索引，且不能为null，不能重复。在InnDB中如果没有创建主键索引，但是有唯一索引，会将唯一索引设为主键索引，否则InnoDB会自动创建一个6Byte的自增主键。

2. 二级索引（辅助索引）

   - 唯一索引：不允许出现重复的数据，但允许数据为null，一张表可以创建多个唯一索引。
   - 普通索引：它的作用只是为了加快检索速度，允许出现重复的数据，允许为null，一张表可以创建多个普通索引。
   - 前缀索引：只适用于字符串类型的数据，它是对文本的前几个字符创建索引，相比普通索引创建的数据更小。
   - 全文索引：主要是为了检索大文本数据中的关键字信息，主要用于搜索引擎数据库。

分类2：

1. 聚簇索引和非聚簇索引
   - 聚簇索引是指索引结构和数据一起存储的索引，主键索引属于聚簇索引。
   - 非聚簇索引是指索引结构和数据分开存储的索引，二级索引属于非聚簇索引。

---

##### 非聚簇索引一定会回表查询吗（覆盖索引）？什么是覆盖索引？

不一定，如果查询的就是主键，只需直接返回主键内容即可，无需回表查询。

----

##### 索引的创建原则

1. 单列索引
2. 联合索引（多列索引）
3. 最左前缀原则
4. 选择合适的字段
   - 不为null的字段
   - 被频繁查询的字段
   - 被作为条件查询的字段
   - 经常被频繁用于连接的字段
5. 不适合创建索引的字段
   - 被频繁更新的字段
   - 不被经常查询的字段
   - 尽可能考虑建立联合索引而不是单列索引
   - 注意避免冗余索引

---

##### 什么是数据库事务，事务有什么用，有什么特性，如何使用，使用于哪些场景？

事务是指逻辑上的一组操作，要么全部成功，要么全部失败。事务是最小的执行单位，不允许分割，不允许嵌套。

事务的特性：

1. 原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么失败。
2. 隔离性：在并发访问数据库时，各并发事务之间数据库是独立的，彼此之间不会互相干扰。
3. 一致性：执行事务前后，数据会保持一致。
4. 持久性：当事务被提交后，它对数据库中数据的改变是持久的，不会因为故障而被影响。

~~~mysql
# 显式开启事务
START transaction | BEGIN

# 提交事务，提交所有修改为永久性
COMMIT

# 事务回滚，撤销所有未提交的修改
ROLLBACK
~~~

事务是用在并发场景中，可以保证数据的有效性。

----

##### 事务并发会导致什么问题？

1. 脏读：当一个事务正在访问数据并修改数据，但事务还未被提交，此时有另外的一个事务访问同一数据，然后使用了这个数据，但是这个数据是原始数据，不是前一事务提交后的数据，所以后一个事务读到的数据就是“脏数据”，依据“脏数据”所做的操作可能是不正确的。

2. 丢失修改：是指两个事务同时读取同一数据，在第一个事务修改了这个数据后，第二个事务也修改了这个数据，这样导致第一个事务内的修改结果被丢失，所以被称为丢失修改。
3. 不可重复读：是指一个事务内多次读取同一数据。一个事务在访问一个数据时，有另外一个数据也访问该数据，但是在第一个事务两次读取该数据之间，数据被另外的事务修改而导致第一个事务两次读取数据的结果不一样，就出现了一个事务内两次读取数据不一样的情况，因此被称为不可重复读。
4. 幻读：它是指一个事务在读取了几行数据后，接着另外一个事务插入了一些数据，这样会导致第一个事务在之后的查询中，第一个事务会发现多了一些不存在的记录。

---

##### 事务的隔离级别，有什么用？

1. 读取未提交，最低的隔离级别，允许读取未提交的数据变更，可能会导致脏读，幻读和不可重复读。
2. 读取已提交，允许读取并发事务已经提交的数据，可以阻止脏读，不一定可以阻止幻读和不可重复读。
3. 可重复读，对同一字段的多次读取结果都是一致的，除非数据是事务自身修改的，可以阻止脏读和不可重复读，不一定可以阻止幻读。
4. 可串行化，最高隔离级别，完全服从ACID，所有的事务逐次执行，事务间不会产生干扰，可以防止脏读，幻读和不可重复读。

InnoDB默认支持的事务隔离级别是可重复读，允许使用Next-Key Lock锁算法来防止幻读，从而可达到可串行化的事务隔离级别。InnoDB存储引擎在分布式事务下才会用到可串行化的隔离级别。

InnoDB存储引擎的锁的算法有三种：

- Record Lock：单行记录上的锁
- Gap Lock：间隙锁，锁定一个范围，不包括记录本身
- Next-Key Lock：上面两种的集合，锁定一个范围，包括记录本身。

查看存储引擎默认支持的隔离级别

~~~mysql
SELECT @@tx_isolation;
SELECT @@transaction_isolation;  #8.0
~~~

----

##### InnoDB 中的事务隔离级别和锁的关系是什么？



---

##### MySQL 中的日志都有哪些，各自的作用分别是什么？

MySQL日志主要包括错误日志，查询日志，慢查询日志，事务日志，二进制日志几大类，主要关注二进制日志（bin log）和事务日志（redo log和undo log）。日志的作用就是记录数据库运行期间的各种状态信息。

主要分类：

1. bin log（归档日志）：用于记录数据库执行的写入性操作信息，不包括查询信息，以二进制的形式保存在磁盘中

   主要使用场景：

   - 主从复制
   - 数据恢复

2. redo log：InnoDB通过redo log日志来支持事务。只记录事务对数据页的修改。

   由两部分组成，分别为内存中的日志缓冲（redo log buffer）和磁盘上的日志文件（redo log file）。

   

3. undo log：

---

##### 一条 SQL 语句在 MySQL 中是如何被执行的

查询语句执行流程：权限校验 ——》查询缓存——》分析器——》优化器——》权限校验——》执行器——》引擎

更新语句执行流程：分析器——》权限校验——》执行器——》redo log（prepared 状态）——》bin log ——》redo log（commit状态）

参考：

- [一条SQL语句在MySQL中如何执行的](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN#rd)

##### MySQL 的覆盖索引和回表查询

回表查询指的是普通索引需要两次扫码索引树才能找到记录，这是因为在普通索引的叶子节点上只存储了主键而没有记录，需要通过主键索引来得到目标记录

---

#### Redis

##### 缓存的基本思想，使用优势，带来的问题

缓存可以提高系统性能，减少请求响应的时间，它的基本思想就是以空间换时间，如CPU cache是内存数据用于解决CPU处理速度和内存不匹配的问题。因此缓存就是为了避免用户在请求数据的时候获取速度过慢，而在数据库上加上一层缓存来弥补。

使用缓存带来的问题：

1. 系统复杂度增加：需要维护缓存和数据库的数据一致性，维护热点缓存等。
2. 系统开发成本增加：单独的缓存服务，消耗的是内存资源

---

##### 缓存的解决方案有哪些？为什么要用分布式缓存而不是本地缓存？

分布式缓存



本地缓存解决方案：

适用于没有分布式要求的，数据量不大的单体架构，可以使用本地缓存，使用Nginx做负载均衡。

1. JDK 自带的 HashMap 和 ConcurrentHashMap
2. Ehcache，Guava cache，Spring Cache，Caffenie本地缓存框架

##### 缓存的读写模式和更新策略

1. Cache Aside Pattern（旁路缓存模式）
2. Read/Write Through Pattern（读写穿透）
3. Write Behind Pattern（异步缓存写入）

##### 缓存框架的特点

1. key-value结构
2. 过期时间
3. 淘汰机制
4. 命中率统计

---

##### 什么是缓存雪崩，有哪些解决办法？

##### 什么是缓存穿透，有什么解决办法？

##### 如何保证缓存与数据库双写时的数据一致性？

##### 简述Redis

Redis是基于C语言开发的数据库，其数据存储在内存中，因此读写速度很快，可以用作缓存，分布式锁，和消息队列。

Redis支持事务，持久化，Lua脚本，多种集群方案。

Redis是最常见的分布式缓存技术选型方案，其他还有Memchache。

---

##### 说说Redis和Memchache的区别和共同点

共同点：

1. 都是基于内存的数据库，一般都被用作缓存
2. 都有过期策略
3. 性能都很高

区别：

1. Redis支持丰富的数据类型（k/v，list，set，zset，hash等），Memchache只支持k/v数据类型
2. Redis支持持久化，可以将内存中的数据保存在磁盘中，重启后可加载再次使用，而Memchache将数据保存在内存中
3. Redis有灾难恢复机制，因为Redis支持持久化。
4. Redis在内存不足时，可以将不用的数据存在磁盘中，而Memchace在服务器内存不足时，会报异常。
5. Redis原生支持cluster模式，而Memchache没有原生的集群模式
6. Memcached是多线程的，非阻塞IO复用的网络模型，Redis使用单线程的多路IO复用模型。
7. Redis支持发布订阅模型，事务，Lua脚本，而Memcached不支持
8. Memecached过期数据的删除策略只使用了惰性删除，Redis同时使用了惰性删除和定期删除

---

##### 缓存数据的处理流程是什么样的？

1. 如果用户请求的数据在缓存中就直接返回
2. 缓存中不存在的话就看数据库中存在与否
3. 数据库中存在的话就更新缓存中的数据
4. 数据库中不存在的话就返回空数据

---



### 计算机网络

#### 状态码

---

#### Cookie 和 Session 的区别

---

### 常用框架

#### Spring

##### AOP和IOC

##### Bean的生命周期和作用域



#### SpringBoot

##### 启动原理

#### Spring MVC

##### 原理

